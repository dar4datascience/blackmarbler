[
  {
    "objectID": "assess-quality.html",
    "href": "assess-quality.html",
    "title": "Assessing Quality of Nighttime Lights Data",
    "section": "",
    "text": "Overview \nThe quality of nighttime lights data can be impacted by a number of factors, particularly cloud cover. To facilitate analysis using high quality data, Black Marble (1) marks the quality of each pixel and (2) in some cases, uses data from a previous date to fill the value—using a temporally-gap filled NTL value.\nThis page illustrates how to examine the quality of nighttime lights data.\n\nSetup\nDaily data\n\nNighttime lights: Gap Filled\nNighttime lights: Non Gap Filled\nQuality flag\nNighttime lights using good quality observations\n\nMonthly/annual data\n\nNighttime lights\nNumber of observations\nQuality\nNighttime lights using good quality observations\n\n\n\n\nSetup \nWe first load packages and obtain a polygon for a region of interest; for this example, we use Switzerland.\n\nlibrary(blackmarbler)\nlibrary(geodata)\nlibrary(sf)\nlibrary(raster)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(exactextractr)\nlibrary(lubridate)\nlibrary(tidyr)\nlibrary(geodata)\nlibrary(knitr)\n\nbearer &lt;- \"BEARER-TOKEN-HERE\"\n\n\nroi_sf &lt;- gadm(country = \"CHE\", level = 0, path = tempdir()) |&gt; st_as_sf()\n\n\n\nDaily Data \nBelow shows an example examining quality for daily data (VNP46A2).\n\nGap filled nighttime lights \nWe download data for January 1st, 2023. When the variable parameter is not specified, bm_raster creates a raster using the Gap_Filled_DNB_BRDF-Corrected_NTL variable for daily data. This variable “gap fills” poor quality observations (ie, pixels with cloud cover) using data from previous days.\n\nntl_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"Gap_Filled_DNB_BRDF-Corrected_NTL\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_m_r &lt;- ntl_r |&gt; raster::mask(roi_sf)\n\nntl_df &lt;- rasterToPoints(ntl_m_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Distribution is skewed, so log\nntl_df$value_adj &lt;- log(ntl_df$value + 1)\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_df,\n    aes(\n      x = x, y = y,\n      fill = value_adj\n    )\n  ) +\n  scale_fill_gradient2(\n    low = \"black\",\n    mid = \"yellow\",\n    high = \"red\",\n    midpoint = 4\n  ) +\n  coord_quickmap() +\n  theme_void() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    legend.position = \"none\"\n  )\n\n\nThe Latest_High_Quality_Retrieval indicates the number of days since the current date that the nighttime lights value comes from for gap filling.\n\nntl_tmp_gap_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"Latest_High_Quality_Retrieval\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_tmp_gap_r &lt;- ntl_tmp_gap_r |&gt; mask(roi_sf)\n\nntl_tmp_gap_df &lt;- rasterToPoints(ntl_tmp_gap_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_tmp_gap_df) &lt;- c(\"value\", \"x\", \"y\")\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_tmp_gap_df,\n    aes(\n      x = x, y = y,\n      fill = value\n    )\n  ) +\n  scale_fill_distiller(palette = \"Spectral\") +\n  coord_quickmap() +\n  theme_void() +\n  labs(\n    fill = \"Temporal\\nGap\\n(Days)\",\n    title = \"Temporal gap between date (Jan 1, 2023)\\nand date of high quality pixel used\"\n  ) +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n\n\nNon gap filled nighttime lights \nInstead of using gap-filled data, we could also just use nighttime light values from the date selected using the DNB_BRDF-Corrected_NTL variable.\n\nntl_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"DNB_BRDF-Corrected_NTL\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_m_r &lt;- ntl_r |&gt; raster::mask(roi_sf)\n\nntl_df &lt;- rasterToPoints(ntl_m_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Distribution is skewed, so log\nntl_df$value_adj &lt;- log(ntl_df$value + 1)\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_df,\n    aes(\n      x = x, y = y,\n      fill = value_adj\n    )\n  ) +\n  scale_fill_gradient2(\n    low = \"black\",\n    mid = \"yellow\",\n    high = \"red\",\n    midpoint = 4\n  ) +\n  coord_quickmap() +\n  theme_void() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    legend.position = \"none\"\n  )\n\n\nWe notice that a number of observations are missing. To understand the extent of missing date, we can use the following code to determine (1) the total number of pixels that cover Switzerland, (2) the total number of non-NA nighttime light pixels, and (3) the proportion of non-NA pixels.\n\nn_pixel &lt;- function(values, coverage_fraction) {\n  length(values)\n}\n\nn_non_na_pixel &lt;- function(values, coverage_fraction) {\n  sum(!is.na(values))\n}\n\nn_pixel_num &lt;- exact_extract(ntl_r, roi_sf, n_pixel)\nn_non_na_pixel_num &lt;- exact_extract(ntl_r, roi_sf, n_non_na_pixel)\n\nprint(n_pixel_num)\nprint(n_non_na_pixel_num)\nprint(n_non_na_pixel_num / n_pixel_num)\n\nBy default, the bm_extract function computes these values:\n\nntl_df &lt;- bm_extract(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = seq.Date(\n    from = ymd(\"2023-01-01\"),\n    to = ymd(\"2023-01-10\"),\n    by = 1\n  ),\n  bearer = bearer,\n  variable = \"DNB_BRDF-Corrected_NTL\"\n)\n\nknitr::kable(ntl_df)\n\nThe below figure shows trends in average nighttime lights (left) and the proportion of the country with a value for nighttime lights (right). For some days, low number of pixels corresponds to low nighttime lights (eg, January 3 and 5th); however, for other days, low number of pixels corresponds to higher nighttime lights (eg, January 9 and 10). On January 3 and 5, missing pixels could have been over typically high-lit areas (eg, cities)—while on January 9 and 10, missing pixels could have been over typically lower-lit areas.\n\n\nShow code to produce figure\n\n\nntl_df %&gt;%\n  dplyr::select(date, ntl_mean, prop_non_na_pixels) %&gt;%\n  pivot_longer(cols = -date) %&gt;%\n  ggplot(aes(\n    x = date,\n    y = value\n  )) +\n  geom_line() +\n  facet_wrap(~name,\n    scales = \"free\"\n  )\n\n\n\n\nQuality \nFor daily data, the quality values are:\n\n0: High-quality, Persistent nighttime lights\n1: High-quality, Ephemeral nighttime Lights\n2: Poor-quality, Outlier, potential cloud contamination, or other issues\n\nWe can map quality by using the Mandatory_Quality_Flag variable.\n\nquality_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"Mandatory_Quality_Flag\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nquality_r &lt;- quality_r |&gt; mask(roi_sf)\n\nquality_df &lt;- rasterToPoints(quality_r, spatial = TRUE) |&gt; as.data.frame()\nnames(quality_df) &lt;- c(\"value\", \"x\", \"y\")\n\nquality_df &lt;- quality_df %&gt;%\n  dplyr::mutate(value_str = case_when(\n    value == 0 ~ \"0: High-quality, persistent\",\n    value == 1 ~ \"1: High-quality, ephemeral\",\n    value == 2 ~ \"2: Poor-quality\"\n  ))\n\n##### Map\nggplot() +\n  geom_raster(\n    data = quality_df,\n    aes(\n      x = x, y = y,\n      fill = value_str\n    )\n  ) +\n  scale_fill_brewer(palette = \"Spectral\", direction = -1) +\n  labs(fill = \"Quality\") +\n  coord_quickmap() +\n  theme_void() +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n\n\nNighttime lights for good quality observations \nThe quality_flag_rm parameter determines which pixels are set to NA based on the quality indicator. By default, no pixels are filtered out (except for those that are assigned a “fill value” by BlackMarble, which are always removed). However, if we only want data for good quality pixels, we can adjust the quality_flag_rm parameter.\n\nntl_good_qual_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A2\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"DNB_BRDF-Corrected_NTL\",\n  quality_flag_rm = 2\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_good_qual_r &lt;- ntl_good_qual_r |&gt; mask(roi_sf)\n\nntl_good_qual_df &lt;- rasterToPoints(ntl_good_qual_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_good_qual_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Distribution is skewed, so log\nntl_good_qual_df$value_adj &lt;- log(ntl_good_qual_df$value + 1)\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_good_qual_df,\n    aes(\n      x = x, y = y,\n      fill = value_adj\n    )\n  ) +\n  scale_fill_gradient2(\n    low = \"black\",\n    mid = \"yellow\",\n    high = \"red\",\n    midpoint = 4\n  ) +\n  coord_quickmap() +\n  theme_void() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    legend.position = \"none\"\n  )\n\n\n\n\n\nMonthly/Annual Data \nBelow shows an example examining quality for monthly data (VNP46A3). The same approach can be used for annual data (VNP46A4); the variables are the same for both monthly and annual data.\n\nNighttime Lights \nWe download data for January 2023. When the variable parameter is not specified, bm_raster creates a raster using the NearNadir_Composite_Snow_Free variable for monthly and annual data—which is nighttime lights, removing effects from snow cover.\n\nntl_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A3\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"NearNadir_Composite_Snow_Free\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_r &lt;- ntl_r |&gt; mask(roi_sf)\n\nntl_df &lt;- rasterToPoints(ntl_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Distribution is skewed, so log\nntl_df$value_adj &lt;- log(ntl_df$value + 1)\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_df,\n    aes(\n      x = x, y = y,\n      fill = value_adj\n    )\n  ) +\n  scale_fill_gradient2(\n    low = \"black\",\n    mid = \"yellow\",\n    high = \"red\",\n    midpoint = 4\n  ) +\n  coord_quickmap() +\n  theme_void() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    legend.position = \"none\"\n  )\n\n\n\n\nNumber of Observations \nBlack Marble removes poor quality observations, such as pixels covered by clouds. To determine the number of observations used to generate nighttime light values for each pixel, we add _Num to the variable name.\n\ncf_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A3\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"NearNadir_Composite_Snow_Free_Num\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\ncf_r &lt;- cf_r |&gt; mask(roi_sf)\n\ncf_df &lt;- rasterToPoints(cf_r, spatial = TRUE) |&gt; as.data.frame()\nnames(cf_df) &lt;- c(\"value\", \"x\", \"y\")\n\ncf_df$value &lt;- cf_df$value %&gt;% as.factor()\n\n##### Map\nggplot() +\n  geom_raster(\n    data = cf_df,\n    aes(\n      x = x, y = y,\n      fill = value\n    )\n  ) +\n  scale_fill_viridis_d() +\n  labs(fill = \"Number of\\nObservations\") +\n  coord_quickmap() +\n  theme_void() +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n\n\nQuality \nFor monthly and annual data, the quality values are:\n\n0: Good-quality, The number of observations used for the composite is larger than 3\n1: Poor-quality, The number of observations used for the composite is less than or equal to 3\n2: Gap filled NTL based on historical data\n\nWe can map quality by adding _Quality to the variable name.\n\nquality_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A3\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"NearNadir_Composite_Snow_Free_Quality\"\n)\n\n\n\nShow code to produce map\n\n\n#### Prep data\nquality_r &lt;- quality_r |&gt; mask(roi_sf)\n\nquality_df &lt;- rasterToPoints(quality_r, spatial = TRUE) |&gt; as.data.frame()\nnames(quality_df) &lt;- c(\"value\", \"x\", \"y\")\n\nquality_df &lt;- quality_df %&gt;%\n  dplyr::mutate(value_str = case_when(\n    value == 0 ~ \"0: Good quality\",\n    value == 1 ~ \"1: Poor quality\",\n    value == 2 ~ \"2: Gap filled\"\n  ))\n\n##### Map\nggplot() +\n  geom_raster(\n    data = quality_df,\n    aes(\n      x = x, y = y,\n      fill = value_str\n    )\n  ) +\n  scale_fill_brewer(palette = \"Spectral\", direction = -1) +\n  labs(fill = \"Quality\") +\n  coord_quickmap() +\n  theme_void() +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5))\n\n\n\n\nNighttime lights for good quality observations \nThe quality_flag_rm parameter determines which pixels are set to NA based on the quality indicator. By default, no pixels are filtered out (except for those that are assigned a “fill value” by BlackMarble, which are always removed). However, if we also want to remove poor quality pixels and remove pixels that are gap filled, we can adjust the quality_flag_rm parameter.\n\nntl_good_qual_r &lt;- bm_raster(\n  roi_sf = roi_sf,\n  product_id = \"VNP46A3\",\n  date = \"2023-01-01\",\n  bearer = bearer,\n  variable = \"NearNadir_Composite_Snow_Free\",\n  quality_flag_rm = c(1, 2)\n) # 1 = poor quality; 2 = gap filled based on historical data\n\n\n\nShow code to produce map\n\n\n#### Prep data\nntl_good_qual_r &lt;- ntl_good_qual_r |&gt; mask(roi_sf)\n\nntl_good_qual_df &lt;- rasterToPoints(ntl_good_qual_r, spatial = TRUE) |&gt; as.data.frame()\nnames(ntl_good_qual_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Distribution is skewed, so log\nntl_good_qual_df$value_adj &lt;- log(ntl_good_qual_df$value + 1)\n\n##### Map\nggplot() +\n  geom_raster(\n    data = ntl_good_qual_df,\n    aes(\n      x = x, y = y,\n      fill = value_adj\n    )\n  ) +\n  scale_fill_gradient2(\n    low = \"black\",\n    mid = \"yellow\",\n    high = \"red\",\n    midpoint = 4\n  ) +\n  coord_quickmap() +\n  theme_void() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    legend.position = \"none\"\n  )"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BlackMarbleR",
    "section": "",
    "text": "This page brought to you by https://example.com"
  },
  {
    "objectID": "index.html#comments",
    "href": "index.html#comments",
    "title": "BlackMarbleR",
    "section": "Comments",
    "text": "Comments\nIn logic for extracting bm_extract, when its 1 file it drops the geometry then exact_extracts but when its many it first extracts then drops the geometry. This is a bug?"
  },
  {
    "objectID": "index.html#next-steps",
    "href": "index.html#next-steps",
    "title": "BlackMarbleR",
    "section": "Next steps",
    "text": "Next steps\n\nperformance tuning\nAdding vignettes (quarto docs?)\nof use cases and considerations\nmigrate to cli package\n[! ] Fix Docs, Roxygen2\nlet user know how many tiles are gonna be process cause it timely\nMore tests (priority)\n\n[!] test bm_extract (next)\n[X!] test bm_raster\ntest quality flags\ntest based off readme examples\n\nbm raster test\nbm extract tests"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "BlackMarbleR",
    "section": "Overview",
    "text": "Overview\nBlackMarbleR is a R package that provides a simple way to use nighttime lights data from NASA’s Black Marble. Black Marble is a NASA Earth Science Data Systems (ESDS) project that provides a product suite of daily, monthly and yearly global nighttime lights. This package automates the process of downloading all relevant tiles from the NASA LAADS DAAC to cover a region of interest, converting and mosaicing the raw files (in HDF5 format) to georeferenced rasters.\n\nInstallation\nBearer token\nUsage\n\nSetup\nMake raster\nMake raster stack across multiple time periods\nMake map\nMake figure of trends in nighttime lights\nWorkflow to update data\n\nFunctions and arguments\n\nFunctions\nRequired Arguments\nOptional Arguments\nArgument only for bm_extract\n\nBlack Marble Resources"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "BlackMarbleR",
    "section": "Installation ",
    "text": "Installation \nThe package can be installed via CRAN.\ninstall.packages(\"blackmarbler\")\nTo install the development version from Github:\n# install.packages(\"devtools\")\ndevtools::install_github(\"worldbank/blackmarbler\")"
  },
  {
    "objectID": "index.html#bearer-token",
    "href": "index.html#bearer-token",
    "title": "BlackMarbleR",
    "section": "Bearer Token ",
    "text": "Bearer Token \nThe function requires using a Bearer Token; to obtain a token, follow the below steps:\n\nGo to the NASA LAADS Archive\nClick “Login” (bottom on top right); create an account if needed.\nClick “See wget Download Command” (bottom near top, in the middle)\nAfter clicking, you will see text that can be used to download data. The “Bearer” token will be a long string in red.\n\nAfter logging in, the below will show the bearer token in red instead of INSERT_DOWNLOAD_TOKEN_HERE. Sometimes, after logging in, the NASA website will redirect to another part of the website. To obtain the bearer token, just navigate to the NASA LAADS Archive after logging in."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "BlackMarbleR",
    "section": "Usage ",
    "text": "Usage \n\nSetup \nBefore downloading and extracting Black Marble data, we first load packages, define the NASA bearer token, and define a region of interest.\n#### Setup\n# Load packages\nlibrary(blackmarbler)\nlibrary(geodata)\nlibrary(sf)\nlibrary(raster)\nlibrary(ggplot2)\n\n#### Define NASA bearer token\nbearer &lt;- \"BEARER-TOKEN-HERE\"\n\n### ROI\n# Define region of interest (roi). The roi must be (1) an sf polygon and (2)\n# in the WGS84 (epsg:4326) coordinate reference system. Here, we use the\n# getData function to load a polygon of Ghana\nroi_sf &lt;- gadm(country = \"GHA\", level=1, path = tempdir()) |&gt; st_as_sf()\n\n\nMake raster of nighttime lights \nThe below example shows making daily, monthly, and annual rasters of nighttime lights for Ghana.\n### Daily data: raster for February 5, 2021\nr_20210205 &lt;- bm_raster(roi_sf = roi_sf,\n                        product_id = \"VNP46A2\",\n                        date = \"2021-02-05\",\n                        bearer = bearer)\n\n### Monthly data: raster for October 2021\nr_202110 &lt;- bm_raster(roi_sf = roi_sf,\n                      product_id = \"VNP46A3\",\n                      date = \"2021-10-01\", # The day is ignored\n                      bearer = bearer)\n\n### Annual data: raster for 2021\nr_2021 &lt;- bm_raster(roi_sf = roi_sf,\n                    product_id = \"VNP46A4\",\n                    date = 2021,\n                    bearer = bearer)\n\n\nMake raster stack of nighttime lights across multiple time periods \nTo extract data for multiple time periods, add multiple time periods to date. The function will return a raster stack, where each raster band corresponds to a different date. The below code provides examples getting data across multiple days, months, and years.\n#### Daily data in March 2021\nr_daily &lt;- bm_raster(roi_sf = roi_sf,\n                     product_id = \"VNP46A3\",\n                     date = seq.Date(from = ymd(\"2021-03-01\"), to = ymd(\"2021-03-31\"), by = \"day\"),\n                     bearer = bearer)\n\n#### Monthly aggregated data in 2021 and 2022\nr_monthly &lt;- bm_raster(roi_sf = roi_sf,\n                       product_id = \"VNP46A3\",\n                       date = seq.Date(from = ymd(\"2021-01-01\"), to = ymd(\"2022-12-01\"), by = \"month\"),\n                       bearer = bearer)\n\n#### Yearly aggregated data in 2012 and 2021\nr_annual &lt;- bm_raster(roi_sf = roi_sf,\n                      product_id = \"VNP46A4\",\n                      date = 2012:2021,\n                      bearer = bearer)\n\n\nMap of nighttime lights \nUsing one of the rasters, we can make a map of nighttime lights\n#### Make raster\nr &lt;- bm_raster(roi_sf = roi_sf,\n               product_id = \"VNP46A3\",\n               date = \"2021-10-01\",\n               bearer = bearer)\n\n#### Prep data\nr &lt;- r |&gt; mask(roi_sf)\n\nr_df &lt;- rasterToPoints(r, spatial = TRUE) |&gt; as.data.frame()\nnames(r_df) &lt;- c(\"value\", \"x\", \"y\")\n\n## Remove very low values of NTL; can be considered noise\nr_df$value[r_df$value &lt;= 2] &lt;- 0\n\n## Distribution is skewed, so log\nr_df$value_adj &lt;- log(r_df$value+1)\n\n##### Map\np &lt;- ggplot() +\n  geom_raster(data = r_df,\n  aes(x = x, y = y,\n  fill = value_adj)) +\n  scale_fill_gradient2(low = \"black\",\n                       mid = \"yellow\",\n                       high = \"red\",\n                       midpoint = 4.5) +\n  labs(title = \"Nighttime Lights: October 2021\") +\n  coord_quickmap() +\n  theme_void() +\n  theme(plot.title = element_text(face = \"bold\", hjust = 0.5),\n  legend.position = \"none\")\n\n\n\n\n\nTrends over time \nWe can use the bm_extract function to observe changes in nighttime lights over time. The bm_extract function leverages the exactextractr package to aggregate nighttime lights data to polygons. Below we show trends in annual nighttime lights data across Ghana’s first administrative divisions.\n#### Extract annual data\nntl_df &lt;- bm_extract(roi_sf = roi_sf,\n                     product_id = \"VNP46A4\",\n                     date = 2012:2022,\n                     bearer = bearer)\n\n#### Trends over time\nntl_df |&gt;\n  ggplot() +\n  geom_col(aes(x = date,\n  y = ntl_mean),\n  fill = \"darkorange\") +\n  facet_wrap(~NAME_1) +\n  labs(x = NULL,\n       y = \"NTL Luminosity\",\n       title = \"Ghana Admin Level 1: Annual Average Nighttime Lights\") +\n  scale_x_continuous(labels = seq(2012, 2022, 4),\n                     breaks = seq(2012, 2022, 4)) +\n  theme_minimal() +\n  theme(strip.text = element_text(face = \"bold\"))\n\n\n\n\n\nWorkflow to update data \nSome users may want to monitor near-real-time changes in nighttime lights. For example, daily Black Marble nighttime lights data is updated regularly, where data is available roughly on a week delay; same use cases may require examining trends in daily nighttime lights data as new data becomes available. Below shows example code that could be regularly run to produce an updated daily dataset of nighttime lights.\nThe below code produces a dataframe of nighttime lights for each date, where average nighttime lights for Ghana’s 1st administrative division is produced. The code will check whether data has already been downloaded/extracted for a specific date, and only download/extract new data.\n# Create directories to store data\ndir.create(file.path(getwd(), \"bm_files\"))\ndir.create(file.path(getwd(), \"bm_files\", \"daily\"))\n\n# Extract daily-level nighttime lights data for Ghana's first administrative divisions.\n# Save a separate dataset for each date in the `\"~/Desktop/bm_files/daily\"` directory.\n# The code extracts data from January 1, 2023 to today. Given that daily nighttime lights\n# data is produced on roughly a week delay, the function will only extract data that exists;\n# it will skip extracting data for dates where data has not yet been produced by NASA Black Marble.\nbm_extract(roi_sf = roi_sf,\n           product_id = \"VNP46A2\",\n           date = seq.Date(from = ymd(\"2023-01-01\"), to = Sys.Date(), by = 1),\n           bearer = bearer,\n           output_location_type = \"file\",\n           file_dir = file.path(getwd(), \"bm_files\", \"daily\"))\n\n# Append daily-level datasets into one file\nfile.path(getwd(), \"bm_files\", \"daily\") |&gt;\n  list.files(pattern = \"*.Rds\",\n  full.names = T) |&gt;\n  map_df(readRDS) |&gt;\n  saveRDS(file.path(getwd(), \"bm_files\", \"ntl_daily.Rds\"))"
  },
  {
    "objectID": "index.html#functions-and-arguments",
    "href": "index.html#functions-and-arguments",
    "title": "BlackMarbleR",
    "section": "Functions and arguments ",
    "text": "Functions and arguments \n\nFunctions \nThe package provides two functions.\n\nbm_raster produces a raster of Black Marble nighttime lights.\nbm_extract produces a dataframe of aggregated nighttime lights to a region of interest (e.g., average nighttime lights within US States).\n\nBoth functions take the following arguments:\n\n\nRequired arguments \n\nroi_sf: Region of interest; sf polygon. Must be in the WGS 84 (epsg:4326) coordinate reference system. For bm_extract, aggregates nighttime lights within each polygon of roi_sf.\nproduct_id: One of the following:\n\n\"VNP46A1\": Daily (raw)\n\"VNP46A2\": Daily (corrected)\n\"VNP46A3\": Monthly\n\"VNP46A4\": Annual\n\ndate: Date of raster data. Entering one date will produce a raster. Entering multiple dates will produce a raster stack.\n\nFor product_ids \"VNP46A1\" and \"VNP46A2\", a date (eg, \"2021-10-03\").\nFor product_id \"VNP46A3\", a date or year-month (e.g., \"2021-10-01\", where the day will be ignored, or \"2021-10\").\nFor product_id \"VNP46A4\", year or date (e.g., \"2021-10-01\", where the month and day will be ignored, or 2021).\n\nbearer: NASA bearer token. For instructions on how to create a token, see here.\n\n\n\nOptional arguments \n\nvariable: Variable to used to create raster (default: NULL). For information on all variable choices, see here; for VNP46A1, see Table 3; for VNP46A2 see Table 6; for VNP46A3 and VNP46A4, see Table 9. If NULL, uses the following default variables:\n\nFor product_id \"VNP46A1\", uses DNB_At_Sensor_Radiance_500m.\nFor product_id \"VNP46A2\", uses Gap_Filled_DNB_BRDF-Corrected_NTL.\nFor product_ids \"VNP46A3\" and \"VNP46A4\", uses NearNadir_Composite_Snow_Free.\n\nquality_flag_rm: Quality flag values to use to set values to NA. Each pixel has a quality flag value, where low quality values can be removed. Values are set to NA for each value in ther quality_flag_rm vector. (Default: NULL).\n\nFor VNP46A1 and VNP46A2 (daily data):\n\n0: High-quality, Persistent nighttime lights\n1: High-quality, Ephemeral nighttime Lights\n2: Poor-quality, Outlier, potential cloud contamination, or other issues\n\nFor VNP46A3 and VNP46A4 (monthly and annual data):\n\n0: Good-quality, The number of observations used for the composite is larger than 3\n1: Poor-quality, The number of observations used for the composite is less than or equal to 3\n2: Gap filled NTL based on historical data\n\n\ncheck_all_tiles_exist: Check whether all Black Marble nighttime light tiles exist for the region of interest. Sometimes not all tiles are available, so the full region of interest may not be covered. If TRUE, skips cases where not all tiles are available. (Default: TRUE).\ninterpol_na: When data for more than one date is downloaded, whether to interpolate NA values in rasters using the raster::approxNA function. Additional arguments for the raster::approxNA function can also be passed into bm_raster/bm_extract (eg, method, rule, f, ties, z, NA_rule). (Default: FALSE).\noutput_location_type: Where output should be stored (default: r_memory). Either:\n\nr_memory where the function will return an output in R\nfile where the function will export the data as a file. For bm_raster, a .tif file will be saved; for bm_extract, a .Rds file will be saved. A file is saved for each date. Consequently, if date = c(2018, 2019, 2020), three datasets will be saved: one for each year. Saving a dataset for each date can facilitate re-running the function later and only downloading data for dates where data have not been downloaded.\n\n\nIf output_location_type = \"file\", the following arguments can be used:\n\nfile_dir: The directory where data should be exported (default: NULL, so the working directory will be used)\nfile_prefix: Prefix to add to the file to be saved. The file will be saved as the following: [file_prefix][product_id]_t[date].[tif/Rds]\nfile_skip_if_exists: Whether the function should first check wither the file already exists, and to skip downloading or extracting data if the data for that date if the file already exists (default: TRUE). If the function is first run with date = c(2018, 2019, 2020), then is later run with date = c(2018, 2019, 2020, 2021), the function will only download/extract data for 2021. Skipping existing files can facilitate re-running the function at a later date to download only more recent data.\n…: Additional arguments for raster::approxNA, if interpol_na = TRUE\n\n\n\nArgument for bm_extract only \n\naggregation_fun: A vector of functions to aggregate data (default: \"mean\"). The exact_extract function from the exactextractr package is used for aggregations; this parameter is passed to fun argument in exactextractr::exact_extract.\nadd_n_pixels: Whether to add a variable indicating the number of nighttime light pixels used to compute nighttime lights statistics (eg, number of pixels used to compute average of nighttime lights). When TRUE, it adds three values: n_non_na_pixels (the number of non-NA pixels used for computing nighttime light statistics); n_pixels (the total number of pixels); and prop_non_na_pixels the proportion of the two. (Default: TRUE)."
  },
  {
    "objectID": "index.html#black-marble-resources",
    "href": "index.html#black-marble-resources",
    "title": "BlackMarbleR",
    "section": "Black Marble Resources ",
    "text": "Black Marble Resources \nFor more information on NASA Black Marble, see:\n\nAcademic paper\nSubstack Post\nWebinar"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "benchmark_reading_laads_remote_csv.html",
    "href": "benchmark_reading_laads_remote_csv.html",
    "title": "Benchmark Reading LAADS Remote CSV: readr vs duckdb",
    "section": "",
    "text": "library(readr)\nlibrary(dplyr)\nlibrary(duckdb)\n#install.packages(\"microbenchmark\")\nlibrary(microbenchmark)\n\n\n# Renamed functions with emphasized package names\nreadr_laads_vnp46_h5_file_names &lt;- function(laads_url) {\n  readr::read_csv(laads_url,\n                        show_col_types = FALSE) |&gt;\n    dplyr::mutate(\n      year = year,\n      day = day\n    )\n}\n\nduckdb_laads_vnp46_h5_file_names &lt;- function(quack_conn, laads_url) {\n  dplyr::tbl(quack_conn,\n             glue::glue(\"read_csv('{laads_url}', auto_detect = true)\")\n  ) |&gt;\n    dplyr::mutate(\n      year = year,\n      day = day\n    ) |&gt;\n    dplyr::collect()\n}\n\n\nproduct_id &lt;- \"VNP46A2\"\nyear &lt;- \"2023\"\nday &lt;- \"001\"\nquack_conn &lt;- dbConnect(duckdb::duckdb(), \":memory:\")\n      duckdb::dbSendQuery(quack_conn,\n                        \"INSTALL httpfs;\n                        LOAD httpfs;\")\nlaads_url &lt;- glue::glue(\"https://ladsweb.modaps.eosdis.nasa.gov/archive/allData/5000/{product_id}/{year}/{day}.csv\")\n\n\nbenchmark_result &lt;- microbenchmark(\n  readr_laads_vnp46_h5_file_names(laads_url),\n  duckdb_laads_vnp46_h5_file_names(quack_conn, laads_url),\n  times = 10\n)\n\n\nprint(benchmark_result)"
  },
  {
    "objectID": "testing_webr.html",
    "href": "testing_webr.html",
    "title": "Test Site",
    "section": "",
    "text": "This page brought to you by https://example.com\n\nwebR in Quarto HTML Documents\nThis is a webR-enabled code cell in a Quarto HTML document.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  }
]